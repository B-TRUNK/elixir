The pipe operator |> passes the result of an expression as the first parameter of another expression.

Programming can get messy. So messy in fact that function calls can get so embedded that they become difficult to follow. Take the following nested functions into consideration:

iex> foo(bar(baz(new_function(other_function()))))

Elixir takes a pragmatic approach to this syntactical chaos by giving us the pipe operator. The pipe operator which looks like |> takes the result of one expression, and passes it on.

iex> other_function() |> new_function() |> baz() |> bar() |> foo()

• Tokenize String (loosely)
"Elixir rocks" |> String.split()
["Elixir", "rocks"]

• Uppercase all the tokens
"Elixir rocks" |> String.upcase() |> String.split()
["ELIXIR", "ROCKS"]

• Check ending
"elixir" |> String.ends_with?("ixir")
true

#Best Practice
============

the arity of a function is more than 1, then make sure to use parentheses. This doesn’t matter much to Elixir, but it matters to other programmers who may misinterpret your code. It does matter with the pipe operator though. For example, if we take our third example, and remove the parentheses from String.ends_with?/2, we are met with the following warning.

"elixir" |> String.ends_with? "ixir"
warning: parentheses are required when piping into a function call.
For example: 

foo 1 |> bar 2 |> baz 3 is ambiguous and should be written as foo(1) |> bar(2) |> baz(3)
true
